// bring in dependencies
const express = require('express')
const router = express.Router()
// Bcrypt dependency
const bcrypt = require('bcryptjs')
// gravatar dependency
const gravatar = require('gravatar')
// JWT dependency
const jwt = require('jsonwebtoken')
// config dependency
const config = require('config')

// used for checking to see if inputed stuff is correct
const { check, validationResult } = require('express-validator')

// Bring in user model
const User = require('../../models/User')
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @Route                                   POST api/users @@
// @Description                             Test Route     @@
// @Access                                  Public         @@
router.post('/',
// run the actual check here for validation that inputed stuff is correct
// check('*what we are checking*', '*Custom error message*').not()*means it can not be something*.isEmpyt()*can not be empty*
  check('name', 'Name is Required').not().isEmpty(),
  // check('*what we are checking*', '*Custom error message*').isEmail()*must be email*
  check('email', 'Please enter a valid email').isEmail(),
  // check('*what we are checking*', '*Custom error message*').isLength({min: '*min length you want*'})*must be certain length*

  check('password', 'please enter pasword with 6 or more characters').isLength({ min: 6 }),
  async (req, res) => {
    // errors is validation result that takes in information sent in by post request (what comes from the user input)
    const errors = validationResult(req)
    // if the error value is not empty then do the following
    if (!errors.isEmpty()) {
      // send 400 request response (bad request) ** send the request in .json form and pull errors from the check done in the post (array of errors)

      return res.status(400).json({ errors: errors.array() })
    }

    // Pull information out of req.body by destructuring
    const { name, email, password } = req.body
    // take req.body and try to do these things
    try {
      // see if user exists by searching email(findOne is used to pick a variable to look for)
      let user = await User.findOne({ email })
      // if user is found then run this
      if (user) {
        // run status error of 400 and bring in json text version of the error array to server
        res.status(400).json({ error: [{ msg: 'User already exists ' }] })
      }
      // Get users gravatar

      // make avatar varaible be what is pulled from gravatar using the email and pass through options s, r, d
      const avatar = gravatar.url(email, {
        // sets size in pixels
        s: '200',
        // sets rating for images (not adult images)
        r: 'pg',
        // sets default image
        d: 'mm'
      })
      // create user instance to work with gravatar
      user = new User({
        name,
        email,
        avatar,
        password
      })

      // Encrypt password using bcrypt

      // create the sale to hash with
      // genSalt is amount of passes of encryption 10 is min recomended
      const salt = await bcrypt.genSalt(10)
      // hash password using the password that was put into the user instance with the salt generated by gensalt
      // and make that be the new user.password
      user.password = await bcrypt.hash(password, salt)

      // actually save the user now that we hashed the password
      await user.save()

      // Return Jsonwebtoken
      // this saves the new user information as a payload for jwt
      const payload = {
        // this pulls user instance and assigns user.id to id which was created by mongo when they were added to the server
        user: {
          id: user.id
        }
      }
      // create jwt token using the payload and the secret that is found in default json throught using config dependency
      jwt.sign(
        // uses payload we created with user id
        payload,
        // uses jwt secret given through config jwtToken
        config.get('jwtSecret'),
        // *optional* gives time limit for token
        { expiresIn: 3600 },
        // possible error, token itself
        (err, token) => {
          // if there is an error
          if (err) throw err
          // if no error send token information
          res.json({ token })
        }
      )
      // if the try fails then run this error
    } catch (err) {
      // console log error message
      console.error(err.message)
      // send error status
      res.status(500).send('Server dun Goofed')
    }
  })

// export
module.exports = router
